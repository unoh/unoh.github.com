---
layout: post
title: "シェル(bash)スクリプトを書くときのTips"
---
{% raw %}
尾藤正人(a.k.a BTO)です<br />
<br />
UNIXを使う時にはシェルスクリプトをよく使います。<br />
ちょっとしたコマンドを実行するには、シェルスクリプトは非常に便利です。<br />
今回はシェルスクリプトを書くときに覚えておいた方が便利なTipsを紹介します。<br />
<br />
<h3>非互換性</h3><br />
<br />
ここで紹介するものは基本的にbashで動作するものになります。<br />
伝統的なBourne Shellでは動作しないことが多くあると思います。<br />
しかしながら最近はbashがメインで使われることが多いので、"だいだいの環境で動くからおk"ぐらいのノリで使ってもらえればと思います。<br />
<br />
<h3>$(...)</h3><br />
<br />
コマンドを"$(", ")"で囲むと実行結果をコマンドラインに代入してくれます。<br />
一見これは"`"(バッククオート)と同じに見えますが、"$()"にはネストができるという利点があります。<br />
<br />
例えばシェルスクリプト自身の絶対パスを取得するのは次のようにできます。<br />
<br />
<pre class="code"><br />
echo $(cd $(dirname $0);pwd)<br />
</pre><br />
<br />
バッククオートだと一時変数に代入しないとできませんが、"$()"を使うとネストが可能なので、一発で取得する事ができます。<br />
ちなみにこれは、相対パスでも絶対パスでもうまく動作します。<br />
<br />
<h3>((...)), $((...))</h3><br />
<br />
元々シェルは数値演算能力を持たないので、シェルスクリプト内で数値演算を行うには"expr"という外部コマンドを呼び出していました。<br />
最近のシェルだと"((", "))"で囲むことで数値演算を行ってくれるようになってます。<br />
"((...))"を評価した結果がそれぞれ、"0", "0以外"で終了ステータスが "1", "0"になります(ややこしや〜)。<br />
演算結果をコマンドラインに代入したい場合は"$((", "))"で囲めばできます。<br />
<br />
"$((...))", "((...))"を使うメリットはいくつかあります。<br />
<br />
<ul><br />
<li>内部コマンドなので処理が速い</li><br />
<li>演算子の間にスペースをあける必要がない</li><br />
<li><strike>浮動小数点が扱える</strike>(bashでは使えなくて、zshの話でした。ご指摘ありがとうございます)</li><br />
</ul><br />
<br />
<pre class="code"><br />
if ((1)); then    # ((1))は終了ステータスが"0"なので"true"が表示される<br />
  echo true<br />
else<br />
  echo false<br />
fi<br />
</pre><br />
<br />
<pre class="code"><br />
$ echo $((1+2))    # 演算子の間にスペースがいらない<br />
3<br />
$ echo $(expr 1+2)   # exprだと演算子の間にスペースが必要<br />
1+2<br />
$ echo $(expr 1 + 2)    # スペースあけるとうまくいく<br />
3<br />
<strike>$ echo $((1.1+2.2))    # 浮動小数点もいける<br />
3.3000000000000003<br />
$ echo $(expr 1.1 + 2.2)    # exprだと浮動小数点はダメ<br />
expr: non-numeric argument</strike><br />
</pre><br />
<br />
<h3>read(Borne Shellでも使える?)</h3><br />
<br />
findの出力結果をベースに大量のファイルに一気に処理を行う時はどうやるでしょうか。<br />
よくみかけるのが、こんなスクリプトです。<br />
<br />
<pre class="code"><br />
for f in $(find ...); do<br />
  echo $f<br />
  echo $(basename $f)<br />
done<br />
</pre><br />
<br />
これは"find"の実行結果が長くない時には、うまく動作します。<br />
"find"の実行結果が長いときによく利用するのが"xargs"です。<br />
<br />
<pre class="code"><br />
find ... | xargs command<br />
</pre><br />
<br />
xargsは僕も大好きなコマンドの1つで、1つのコマンドを複数ファイルに実行するのにとても便利です。<br />
ただ複数のコマンドを実行したい時に不便です。<br />
<br />
これは read という内部コマンドを使うとうまく動作します。<br />
read は標準入力から読み込んだデータを引数に指定した変数に代入します。<br />
"find"の出力結果をパイプで流して、"read"を使って順番に変数に代入すると、"find"の実行結果が長くても動作しますし、複数のコマンドの実行も簡単に行えます。<br />
<br />
<pre class="code"><br />
find ... | while read f; do<br />
  echo $f<br />
  echo $(basename $f)<br />
done<br />
</pre><br />
<br />
<h3>まとめ</h3><br />
<br />
シェルスクリプトを書く時に覚えておくと便利なTipsを紹介してみました。<br />
他にもいろいろ便利な書き方があるかと思います。<br />
シェルスクリプトは使いこなせるようになると非常に便利です。<br />
みなさんもいろいろ勉強してみてはいかがでしょうか。
{% endraw %}
