---
layout: post
title: "自力でUNIX TIMEを計算してみよう"
---
　Flashエンジニアのくせに今日もFlashの話題を振らないnaoです。こんにちは。<br />
　クビにならないよう努力はしています。<br />
<br />
　今回のお題。何の役に立つのかと問われれば、漢らしく「何の役にもたたん」と答えましょう。しかし、ひょっとしたらいつか、使う日も来るかもしれない。こうして諸葛孔明の様に何事にも用意周到に備える私の部屋はモノで溢れかえっております。<strong><font color=red>みろ、部屋がゴミのようだ</font></strong>。だってさー、PowerBook Duo(270cカラー液晶だぜ)とか、そのうちプレミアつきそうじゃん？いつか本当に必要な時が来たら、その時には声高らかに朗々と<strong>「こんな事もあろうかと」</strong>と宣言をするのである。<br />
<br />
　というわけで今回は、まるで昔使った思い出の品のように、近年すっかり過去の遺物へと変貌し始めているUNIX TIMEです。UNIX TIMEといえば昔Perlのcgiで掲示板スクリプトを作るときなんかにはよく使われましたが、最近ではそこらの無料レンタルサービスでもDBが普通に使えるので、きょう日常用するのはtimestamp型ですよね。人間にも分かりやすいし、なにより遠い未来でも利用できる。それに対してUNIX TIMEは、2038年(2038年問題でググろう)までしか使えません。<br />
　ではなぜ今更UNIX TIMEなのか。それはやっぱり、いつか使うかもしれないじゃん？という個人的なこだわりです。まぁ、使おうと思えばいくらでも使う場面はありますけどね。<strong>あえて使う理由も無い</strong>んですが。<br />
<br />
　UNIX TIMEとは、1970年1月1日0時0分0秒(これをUNIX EPOCHという)より始まるタイムスタンプで、1秒経過すると値が1増えるという非常に扱いやすい性質を持ちます。そのため、例えば1970年1月1日0時1分0秒なら、UNIX TIMEは60というとうに、非常にシンプルです。この性質を利用すれば、例えば現在の時刻が判明すれば、UNIX EPOCHからの秒数を計算して、現在のUNIX TIMEを得ることが出来るのである。今回は、それを計算してみようというわけです。<br />
　勘の良い人はそろそろ気がついたかもしれませんが、実は今回のラボブログ、目的はUNIX TIMEを計算することですが、<font color=red>本質的にはグレゴリオ暦を計算する計算式の話</font>になります。暦が計算できて、UNIX EPOCHからの日数の差分が得られたら、あとはそれを秒数に変換すれば、UNIX TIMEになるのです。<br />
<br />
<p style="margin: 30px 30px; padding: 10px;border:solid"><br />
グレゴリオ暦とは<br><br />
グレゴリオ暦（グレゴリオれき）とは、1582年にローマ教皇グレゴリオ13世がユリウス暦を改良して制定した暦である。現行の太陽暦として世界各国で用いられている。単に新暦（英語：New Style、略称：N.S.、NS）と呼ばれる場合もある。現在使われている西暦はグレゴリオ暦である。<br><br />
以上、wikipedia グレゴリオ暦より引用。<br />
</p><br />
<br />
早い話が、今現在使われている暦の事である。500年近く前に作られたアルゴリズムなんですって。すごいよね。<br />
それでは、さっそくUNIX TIMEの基準となる紀元元年1月1日からUNIX EPOCHまでの経過日数の計算をしてゆきましょう。<br />
<br />
閏年の判定の仕方<br />
閏年の判定は、条件式で書くとこんな感じになります。<br />
<pre class="code"><code>year % 4 == 0 && year % 100 != 0 || year % 400 == 0</code></pre><br />
<br />
<p style="margin: 30px 30px; padding: 10px;border:solid"><br />
1)西暦を4で割って余りが0(4の倍数)の年は閏年<br><br />
2)だけど100で割って余りが0(100の倍数)の年は除外して<br><br />
3)なおかつ400で割った場合に余りが0(400の倍数)の年はやっぱ例外的に閏年<br />
</p><br />
ということですね。<br />
<br />
　これだけ理解しておけば、何かしらのプログラミング言語であれば、forとか構造体を使って暦の紀元元年1月1日からの経過日数を計算できますが、そこは公衆の面前に晒されるラボブログの記事。もう一歩突っ込んで、公式を使ってイッパツで計算しましょう。まぁ、誰にも見せないコードの中身だったら、面倒だから何も考えずforとかで回しちゃいますけどね。<br />
<br />
グレゴリオ暦換算紀元0年1月1日からの経過日数の数え方<br />
ここに「Fairfieldの公式(フェァフィールドのこうしき)」という非常に素晴らしい公式があります。こんなに素晴らしいのに、何故かマイナー。google先生にお伺いしても、あんまり情報がありませんが、今回はコレを使います。<br />
<br />
<pre class="code"><code>Fairfieldの公式による経過日数の算出<br />
365*（ｙ-1）+[ｙ/4]-[ｙ/100]+[ｙ/400]+31+28+1+[306*(ｍ+1)/10]-122+(d-1)</code></pre><br />
<br />
さぁ、ややこしいモノが出てまいりました。まずは、順を追って見ていきましょう。<br />
<p style="margin: 30px 30px; padding: 10px;border:solid">365*（ｙ-1）</p><br />
まずここは簡単。計算したい日の前年までの年数*1年の日数ですね。<br />
<br />
<p style="margin: 30px 30px; padding: 10px;border:solid">+[ｙ/4]-[ｙ/100]+[ｙ/400]</p><br />
次にこちら。ここは、閏年の処理ですね。[ ]の記号はガウス記号ってヤツで、int()と同じ小数点以下切り捨てですですが、これは高校とか大学で習うのかどうか知らないので、一応説明しておきました。自分中卒なので。<br />
ここまでで、計算したい日の前年までの日数が出ます。<br />
<br />
<p style="margin: 30px 30px; padding: 10px;border:solid">+31+28+1+[306*(ｍ+1)/10]-122+(d-1)</p><br />
で、問題はこちら。ここが公式の決定的な肝であり、難関でもあります。<br />
ざっくりと説明すると、この公式では1年間を3月〜14月として計算することで、2月の最終日を1年間の最後の日として扱うことが出来ます。<br />
まず「+31+28+1」この部分が1月と2月(公式中の扱いとしては前年の13月と14月)の日数。<br />
次に「[306*(ｍ+1)/10]」ここが、3月〜12月(公式中では1月〜10月)の日数。<br />
最後に「-122+(d-1)」で、13月と14月の補正と、計算したい日の当月の日数になります。<br />
<br />
ざっくりとした説明になりましたが、こんなものは数字大好きな人が理解していればいいことなので、私のような凡人は、さらにこの式を発展させて、以下のような式を使います。<br />
<pre class="code"><code>365 * y + [y/4] - [y/100] + [y/400] + [306 * (m+1) / 10] + d - 428</code></pre><br />
「428」って何よ、とか言わないでください。元の式を計算すると、まぁなんとなくこんな感じになります。13月と14月の分と、1年の始まりが3月からになるようにしていた分を全部予め計算しておくと出る数字です。<br />
数学が大の苦手の私的には、こっちがありがたい。<br />
<br />
それでは、早速基準となるUNIX EPOCHである1970年1月1日0時0分0秒までの経過日数を計算しましょう。<br />
<br />
<pre class="code"><code>365 * 1970 + [1970/4)]- [1970/100] + [1970/400] + [306 * (1 + 1) / 10] - 428 + 1 = 719161</code></pre><br />
　これで、UNIX EPOCHは、グレゴリオ暦換算紀元元年1月1日から719161日経過している、という事がわかりました。<br />
　次は、この719161を起点として、そこから何日経過しているかを計算します。<br />
<br />
<pre class="code"><code>_EPOC_TIME = 719161;<br />
// Fairfieldの公式で算出した719161日からの経過秒数の算出<br />
diff = ((365 * year + int(year / 4) - int(year / 100) + int(year / 400) + int(306 * (month + 1) / 10) - 428 + day) -  _EPOC_TIME) * 24 *60 * 60;</code></pre><br />
<br />
せっかくなのでFlash Lite 1.1のActionScriptで書いてみました。<br />
これに、時刻を足してあげれば、UNIX TIMEの完成です。<br />
<br />
<pre class="code"><code>_EPOC_TIME = 719161;<br />
UNIX_TIME = ((365 * year + int(year / 4) - int(year / 100) + int(year / 400) + int(306 * (month + 1) / 10) - 428 + day) -  _EPOC_TIME) * 86400 + (hour * 3600) + (minute * 60) + second;</code></pre><br />
<br />
ほら1行でできた。エンジニアっぽいっ！<br />
<br />
　今回はグレゴリオ暦の計算を用いてUNIX TIMEを導き出したわけですが、これを応用すれば、いろいろな事が計算できます。例えば、グレゴリオ暦換算の紀元元年1月1日は月曜日なので、Fairfieldの公式による経過日数を7で割った余りで曜日が判定できます。余り0なら日曜日。6なら土曜日。ちなみに、この割り算の"余り"を求める事をモジュロ演算と言います。演算子の"mod"や"%"のヤツ。サマーウォーズで見たよね？こいつのおかげで、ケンジは得意げになりナツキ先輩はメロメロなわけである。みんな覚えておこう。いつか「こんな事もあろうかと」という日が来るかもしれない。<br />
<br />
　余談ですが、宇宙戦艦ヤマトの工場長兼技師長である真田志郎氏といえば「こんな事もあろうかと」で有名ですが、wikipediaによると<font color=red>劇中にそんなセリフは無い</font>そうです。<br />
<br />
えー、がっかりー。
