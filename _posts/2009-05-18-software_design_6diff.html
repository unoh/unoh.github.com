---
layout: post
title: "Software Design 6月号に「diffの動作原理を知る」の記事を執筆しました"
---
<br />
最近、「何故、君はマウスを2つ同時に使っているんだい？」と聞かれることが多くなったbokkoです。VX Revolution RXは右手用ですが、左手で使うならMicrosoftのArcがオススメです。近頃はフットマウスを買うかどうか真剣に悩んでいます。<br />
<br />
<br />
Software Designには去年にも<a href="http://gihyo.jp/magazine/SD/archive/2008/200810">「ソースを読み，パッチを作成してみよう～GNU GLOBAL，diff，patchの使い方～」</a>という記事を執筆する機会を頂いたので、本誌に執筆するのはこれが二度目になります。<br />
<br />
<br />
今回の内容は以前当ブログに書いた「<a href="http://labs.unoh.net/2008/11/diff_with_c.html">diff with C++</a>」の記事をもっと濃くした感じになっていて、編集距離やLCS、SESの解説に始まり、<a href="http://subversion.tigris.org/">Subversion</a>のdiffエンジンや拙作の<a href="http://code.google.com/p/dtl-cpp/">dtl</a>で使われているWuのO(NP)差分アルゴリズムについて解説しています。<br />
<br />
<br />
WuのO(NP)アルゴリズム(以下Wuのアルゴリズム)や、それによく似たMyersのO(ND)アルゴリズムをはじめとするエディットグラフを使って差分を求めるアルゴリズムは普段何気なく使っているdiffコマンドや各種バージョン管理システムで使われていることからもわかるようにとても有用であり、アルゴリズム自体の美しさやスマートさにも目を見張るものがあります。興味がある方はぜひ手にとって読んでみてください。本記事を通してdiffのアルゴリズムのおもしろさが伝われば幸いです。<br />
<br />
<br />
<span class="mt-enclosure mt-enclosure-image" style="display: inline;"><a href="http://gihyo.jp/magazine/SD/archive/2009/200906"><img alt="sd0906cover.jpgのサムネール画像のサムネール画像" src="http://labs.unoh.net/assets_c/2009/05/sd0906cover-thumb-250x353-11-thumb-250x353-15.jpg" width="250" height="353" class="mt-image-none" style="" /></a></span><br />
<br />
<br />
<h3>お詫びと訂正</h3><br />
<br />
<br />
本記事には訂正箇所が3箇所ほどあります。うち2つは本記事で使用している<a href="http://code.google.com/p/dtl-cpp/">dtl</a>のバージョンが執筆後に0.05から0.06に上がったことによるもので、もう一つはWuのアルゴリズムの計算量に対する私の勘違いによるものです。詳しい内容については<a href="http://gihyo.jp/magazine/SD/archive/2009/200906/support">Software Design 2009年6月号：サポートページ｜gihyo.jp ... 技術評論社</a>をご覧下さい。<br />
<br />
<br />
関係者や読者の方にはご迷惑をおかけしました。すみません。以後、気を付けます。<br />
<br />
<br />
<h3>おまけ</h3><br />
<br />
本記事にはサンプルコードとしてWuのアルゴリズムを使って2つの文字列間の編集距離を求めるC++のプログラムが載っているのですが、ふと思い立って、同じことをするプログラムおよびLCSとSESも計算するプログラムをLuaで書いてみました。だからどうというわけでもないのですが、何か新しいプログラミング言語を触る際に、こんな風に自分にとってなじみのあるアルゴリズムを記述してみるのはその言語を勉強する上で、とてもいい方法だと再確認した次第です。<br />
<br />
<br />
実際に書いていてハマったのですが、Luaではほかの大多数の言語と違って配列や文字列のインデックスが0からではなく1から始まるので、別の言語で記述されたアルゴリズムとかのコードを写経する際は注意しましょう。<br />
<br />
<br />
しかし、この間、プログラマの友達とそんなLuaの独特の挙動について話をしていると、<br />
<br />
<blockquote><br />
<em>まあ、(アルゴリズムの)論文に載っているような擬似コードは配列のインデックスが1から始まってるから、論文の擬似コードを写経する分にはちょうどいいんじゃね？</em><br />
</blockquote><br />
<br />
という感じのことを言われて「ああ、言われてみればそうだなあ」と妙に納得した次第です。とりあえず、今後、論文に載ってる疑似コードを実際のコードに落とす際はまずLuaで書いてそれからCとかC++に書き直すということを実践してみようと思います。<br />
<br />
<br />
話が逸れました。以下にLuaによるWuのアルゴリズムの実装を2種類示します。その1が編集距離のみを計算するバージョン、その2が編集距離に加えてLCS、SESを計算するバージョンになります。なお、<a href="http://code.google.com/p/dtl-cpp/">dtl</a>と違ってワーストケース(LCSが極端に短くなる場合)への対応は行っていません。<br />
<br />
<h3>LuaによるWuのアルゴリズムの実装 その1(編集距離のみ)</h3><br />
<br />
<pre class="code"><br />
-- editDistance.lua<br />
-- Lua5.1.4で動作確認<br />
ONP = {}<br />
function ONP.new (a, b)           -- ONPクラスのコンストラクタ<br />
   local self = {                           -- メンバ変数<br />
      A = a,<br />
      B = b,<br />
      M = string.len(a),<br />
      N = string.len(b),<br />
   }<br />
   function self.editDistance ()  -- 編集距離を計算する<br />
      offset = self.M + 1<br />
      delta  = self.N - self.M<br />
      size   = self.M + self.N + 3<br />
      fp = {}<br />
      for i = 0, size-1 do<br />
	 fp[i] = -1<br />
      end<br />
      p = -1<br />
      repeat<br />
	 p = p + 1<br />
	 for k=-p, delta-1, 1 do<br />
	    fp[k+offset] = self.snake(k, math.max(fp[k-1+offset]+1, fp[k+1+offset]))<br />
	 end<br />
	 for k=delta+p,delta+1, -1 do<br />
	    fp[k+offset] = self.snake(k, math.max(fp[k-1+offset]+1, fp[k+1+offset]))<br />
	 end<br />
	 fp[delta+offset] = self.snake(delta, math.max(fp[delta-1+offset]+1, fp[delta+1+offset]))<br />
      until fp[delta+offset] >= self.N<br />
      return delta + 2 * p<br />
   end<br />
   function self.snake (k, y)     -- 最遠点のy座標を計算する<br />
      x = y - k<br />
      while (x < self.M and y < self.N and <br />
	     string.sub(self.A, x+1, x+1) == string.sub(self.B, y+1, y+1)) <br />
      do<br />
	 x = x + 1<br />
	 y = y + 1<br />
      end<br />
      return y<br />
   end<br />
   if self.M >= self.N then       -- N >= Mになるように調整<br />
      self.A, self.B = self.B, self.A<br />
      self.M, self.N = self.N, self.M<br />
   end<br />
   return self<br />
end<br />
if #arg < 2 then<br />
   error("few argument")<br />
end<br />
a = arg[1]<br />
b = arg[2]<br />
d = ONP.new(a, b)<br />
print("editDistance:" .. d:editDistance())<br />
</pre><br />
<br />
<h4><strong>実行</strong></h4><br />
<br />
<pre class="code"><br />
narazuya@bokkko% lua editDistance.lua abcdef dacfea<br />
6<br />
narazuya@bokkko% lua e.editDistancelua abc abd<br />
2<br />
narazuya@bokkko% <br />
</pre><br />
<br />
<h3>LuaによるWuのアルゴリズムの実装 その2(編集距離、LCS、SES)</h3><br />
<br />
<pre class="code"><br />
-- onp.lua<br />
-- Lua5.1.4で動作確認<br />
ONP = {}<br />
SES_DELETE = -1<br />
SES_COMMON = 0<br />
SES_ADD    = 1<br />
function ONP.new (a, b)          -- ONPクラスのコンストラクタ<br />
   local self = {                          -- メンバ変数<br />
      A = a,<br />
      B = b,<br />
      M = string.len(a),<br />
      N = string.len(b),<br />
      path       = {},<br />
      pathposi   = {},<br />
      P          = {},<br />
      ses        = {},<br />
      seselem    = {},<br />
      lcs        = "",<br />
      editdis    = 0,<br />
      reverse    = false,<br />
   }<br />
   -- getter<br />
   function self.geteditdistance () <br />
      return self.editdis<br />
   end<br />
   function self.getlcs ()<br />
      return self.lcs<br />
   end<br />
   function self.getses ()<br />
      return self.ses<br />
   end<br />
   -- constructor<br />
   function self.P.new (x_, y_, k_)<br />
      local self = { x=x_, y=y_, k=k_ }<br />
      return self<br />
   end<br />
   function self.seselem.new (elem_, type_)<br />
      local self = { elem=elem_, type=type_}<br />
      return self<br />
   end<br />
   -- 差分構築<br />
   function self.compose ()<br />
      offset = self.M + 1<br />
      delta  = self.N - self.M<br />
      size   = self.M + self.N + 3<br />
      fp = {}<br />
      for i = 0, size-1 do<br />
	 fp[i]        = -1<br />
	 self.path[i] = -1<br />
      end<br />
      p = -1<br />
      repeat<br />
	 p = p + 1<br />
	 for k=-p, delta-1, 1 do<br />
	    fp[k+offset] = self.snake(k, fp[k-1+offset]+1, fp[k+1+offset])<br />
	 end<br />
	 for k=delta+p,delta+1, -1 do<br />
	    fp[k+offset] = self.snake(k, fp[k-1+offset]+1, fp[k+1+offset])<br />
	 end<br />
	 fp[delta+offset] = self.snake(delta, fp[delta-1+offset]+1, fp[delta+1+offset])<br />
      until fp[delta+offset] >= self.N<br />
      self.editdis = delta + 2 * p<br />
      r    = self.path[delta+offset]<br />
      epc  = {}<br />
      while r ~= -1 do<br />
	 epc[#epc+1] = self.P.new(self.pathposi[r+1].x, self.pathposi[r+1].y, nil)<br />
	 r = self.pathposi[r+1].k<br />
      end<br />
      self.recordseq(epc)<br />
   end<br />
   function self.snake (k, p, pp)     -- 最遠点のy座標を計算する<br />
      r = 0;<br />
      if p > pp then<br />
	 r = self.path[k-1+offset];<br />
      else<br />
	 r = self.path[k+1+offset];<br />
      end<br />
      y = math.max(p, pp);<br />
      x = y - k<br />
      while (x < self.M and y < self.N and <br />
	     string.sub(self.A, x+1, x+1) == string.sub(self.B, y+1, y+1)) <br />
      do<br />
	 x = x + 1<br />
	 y = y + 1<br />
      end<br />
      self.path[k+offset] = #self.pathposi<br />
      p = self.P.new(x, y, r)<br />
      self.pathposi[#self.pathposi+1] = p<br />
      return y<br />
   end<br />
   function self.recordseq (epc)          -- LCS、SESを記録する<br />
      x_idx,  y_idx  = 1, 1<br />
      px_idx, py_idx = 0, 0<br />
      for i=#epc, 1, -1 do<br />
	 while (px_idx < epc[i].x or py_idx < epc[i].y) do<br />
	    if (epc[i].y - epc[i].x) > (py_idx - px_idx) then<br />
	       elem = string.sub(self.B, y_idx, y_idx)<br />
	       if self.reverse then <br />
		  type = SES_DELETE<br />
	       else<br />
		  type = SES_ADD<br />
	       end<br />
	       self.ses[#self.ses+1] = self.seselem.new(elem, type)<br />
	       y_idx  = y_idx  + 1<br />
	       py_idx = py_idx + 1<br />
	    elseif epc[i].y - epc[i].x < py_idx - px_idx then<br />
	       elem = string.sub(self.A, x_idx, x_idx)<br />
	       if self.reverse then <br />
		  type = SES_ADD<br />
	       else<br />
		  type = SES_DELETE<br />
	       end<br />
	       self.ses[#self.ses+1] = self.seselem.new(elem, type)<br />
	       x_idx  = x_idx  + 1<br />
	       px_idx = px_idx + 1<br />
	    else <br />
	       elem = string.sub(self.A, x_idx, x_idx)<br />
	       type = SES_COMMON<br />
	       self.lcs = self.lcs .. elem<br />
	       self.ses[#self.ses+1] = self.seselem.new(elem, type)<br />
	       x_idx  = x_idx  + 1<br />
	       y_idx  = y_idx  + 1<br />
	       px_idx = px_idx + 1<br />
	       py_idx = py_idx + 1<br />
	    end<br />
	 end<br />
      end<br />
   end<br />
   if self.M >= self.N then       -- N >= Mになるように調整<br />
      self.A, self.B = self.B, self.A<br />
      self.M, self.N = self.N, self.M<br />
      self.reverse = true<br />
   end<br />
   return self<br />
end<br />
if #arg < 2 then<br />
   error("few argument")<br />
end<br />
a = arg[1]<br />
b = arg[2]<br />
d = ONP.new(a, b)<br />
d:compose()<br />
print("editDistance:" .. d:geteditdistance()) -- 編集距離<br />
print("LCS:"          .. d:getlcs())                    -- Longest Common Subsequence<br />
print("SES")<br />
ses = d:getses()                                          -- Shortest Edit Script<br />
for i=1, #ses do<br />
   if ses[i].type == SES_COMMON then<br />
      print("  " .. ses[i].elem)<br />
   elseif ses[i].type == SES_DELETE then<br />
      print("- " .. ses[i].elem)<br />
   elseif ses[i].type == SES_ADD then<br />
      print("+ " .. ses[i].elem)<br />
   end<br />
end<br />
</pre><br />
<br />
<h4><strong>実行</strong></h4><br />
<br />
<pre class="code"><br />
narazuya@bokkko% lua onp.lua abcdef dacfea<br />
editDistance:6<br />
LCS:acf<br />
SES<br />
+ d<br />
  a<br />
- b<br />
  c<br />
- d<br />
- e<br />
   f<br />
+ e<br />
+ a<br />
narazuya@bokkko% lua a.lua abc abd<br />
editDistance:2<br />
LCS:ab<br />
SES<br />
  a<br />
  b<br />
- c<br />
+ d<br />
narazuya@bokkko%<br />
</pre>
